import numpy as np

import importlib.util
import sys
import sysconfig
from string import Template
from pathlib import Path


from .settings import settings
from .compiler import Compiler


class PyCExtension:
    SUFFIX = "__nm_pyext"

    def __init__(
        self,
        name,
        functions,
        do_checks=True,
    ):
        self.name = f"{name}{self.SUFFIX}"
        self.functions = functions
        self.do_checks = do_checks
        self.lib_path = None

    def set_lib_path(self, path):
        self.lib_path = path

    def compile(self, core_lib_name, core_lib_path, directory, compile_flags, backend=None):
        if self.lib_path is not None:
            return self.lib_path

        if backend is None:
            backend = settings.default_backend

        wrapper_src = Path(directory) / f"{self.name}.c"
        self.write(wrapper_src)

        if backend == "fortran":
            libraries = [
                "gfortran",
                "mvec",
                f"python{sys.version_info.major}.{sys.version_info.minor}",
                core_lib_name,
            ]
        elif backend == "c":
            libraries = [
                f"python{sys.version_info.major}.{sys.version_info.minor}",
                core_lib_name,
            ]
        else:
            raise ValueError(f"Unsupported backend: {backend}")
        include_dirs = [sysconfig.get_paths()["include"], np.get_include()]
        additional_flags = ["-DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION"]

        compiler = Compiler("gcc", compile_flags)
        lib = compiler.compile_to_library(
            self.name,
            [wrapper_src],
            directory=directory,
            include_dirs=include_dirs,
            libraries=libraries,
            libraries_dirs=[],
            rpath_dirs=[core_lib_path],
            additional_flags=additional_flags,
        )
        self.set_lib_path(lib)
        return lib

    def load(self, func_name):
        if self.lib_path is None:
            raise RuntimeError("PyCExtension is not compiled yet.")

        spec = importlib.util.spec_from_file_location(self.name, self.lib_path)
        compiled_sub = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(compiled_sub)
        return getattr(compiled_sub, func_name)

    def construct_module(self):
        template = """
#include <Python.h>
#include <numpy/arrayobject.h>

${numpy_wrappers} 

${struct_definitions}

${procedure_definitions}

// Method definition table
static PyMethodDef Methods[] = {
    ${module_procedures}
    {NULL, NULL, 0, NULL}  // Sentinel
};

// Module definition
static struct PyModuleDef ${name} = {
    PyModuleDef_HEAD_INIT,
    "${name}",  // Module name
    NULL,  // Optional module documentation
    -1,
    Methods
};

// Module initialization function
PyMODINIT_FUNC PyInit_${name}(void) {
    import_array();  // Initialize NumPy API
    return PyModule_Create(&${name});
}
"""

        substitutions = {}
        substitutions["name"] = f"{self.name}"

        from .wrappers.numpy_mem import numpy_mem

        substitutions["numpy_wrappers"] = numpy_mem.get_code()

        struct_definitions = {}
        procedure_definitions = []
        module_procedures = []

        for name, args_details, return_specs in self.functions:

            # find the structs
            for arg in args_details:
                if not arg.is_comptime and arg.datatype.is_struct():
                    # bfs to declare all nested structs
                    def bfs(struct):
                        for _, nested_dtype, _ in struct.members:
                            if (
                                nested_dtype.is_struct()
                                and nested_dtype.name not in struct_definitions
                            ):
                                bfs(nested_dtype)
                        struct_definitions[struct.name] = struct.c_declaration()

                    bfs(arg.datatype)

            module_procedures.append(
                "".join(
                    [
                        f'{{"{name}", (PyCFunction)(void(*)(void))nm_{name}, METH_FASTCALL, "Wrapper generated by numeta"}},'
                    ]
                )
            )

            procedure_definitions.append(self.construct_procedure(name, args_details, return_specs))

        substitutions["module_procedures"] = "\n".join(module_procedures)
        substitutions["procedure_definitions"] = "\n".join(procedure_definitions)
        substitutions["struct_definitions"] = "".join(struct_definitions.values())

        module_template = Template(template)
        module_template = module_template.substitute(substitutions)

        return module_template

    def construct_procedure(self, name, args_details, return_specs):
        template = """
void ${fortran_name}(${fortran_args});

static PyObject* ${procedure_name}(PyObject *self, PyObject *const *args, Py_ssize_t nargs) {

    if (nargs != ${n_args}) {
        PyErr_SetString(PyExc_TypeError, "${fortran_name} takes exactly ${n_args} arguments");
        return NULL;
    }

    ${initializations}

    if (PyErr_Occurred()) {
        PyErr_SetString(PyExc_TypeError, "Error occurred while parsing arguments.");
        return NULL;
    }

    ${checks}

    ${return_args_declarations}

    ${fortran_name}(${call_args});

    ${return_args_conversion_to_numpy}

    ${return}
}
"""
        args = [a for a in args_details if not a.is_comptime]

        substitutions = {}
        substitutions["fortran_name"] = name
        substitutions["procedure_name"] = f"nm_{name}"
        substitutions["n_args"] = len(args)

        fortran_args = [self.get_fortran_args(var) for var in args]
        substitutions["initializations"] = "\n    ".join(
            [self.get_initialization(i, var) for i, var in enumerate(args)]
        )

        substitutions["checks"] = ""
        if self.do_checks:
            substitutions["checks"] = "\n    ".join([self.get_check(var) for var in args])

        call_args = [self.get_call_args(var) for var in args]

        substitutions["return_args_declarations"] = "\n"
        substitutions["return_args_conversion_to_numpy"] = ""
        return_vars = []
        for i, (dtype, rank) in enumerate(return_specs):
            if rank != 0:
                substitutions[
                    "return_args_declarations"
                ] += f"\n    npy_intp out_shape_{i}[{rank}];"
                call_args.append(f"out_shape_{i}")
                fortran_args.append(f"npy_intp* out_shape_{i}")

                substitutions["return_args_declarations"] += f"\n    void* out_ptr_{i} = NULL;"
                call_args.append(f"&out_ptr_{i}")
                fortran_args.append(f"void** out_ptr_{i}")
                substitutions[
                    "return_args_conversion_to_numpy"
                ] += f"\n    PyObject* ret_out_{i} = PyArray_SimpleNewFromData({rank}, out_shape_{i}, {dtype.get_cnumpy().upper()}, out_ptr_{i});"
                substitutions[
                    "return_args_conversion_to_numpy"
                ] += f"\n    PyArray_ENABLEFLAGS((PyArrayObject*)ret_out_{i}, NPY_ARRAY_OWNDATA);"
                return_vars.append(f"ret_out_{i}")
            else:
                substitutions[
                    "return_args_declarations"
                ] += f"\n    {dtype.get_cnumpy()} out_val_{i};"
                call_args.append(f"&out_val_{i}")
                fortran_args.append(f"{dtype.get_cnumpy()}* out_val_{i}")
                substitutions[
                    "return_args_conversion_to_numpy"
                ] += f"\n    PyObject* ret_out_{i} = PyArray_Scalar(&out_val_{i}, PyArray_DescrFromType({dtype.get_cnumpy().upper()}), NULL);"
                return_vars.append(f"ret_out_{i}")

        substitutions["fortran_args"] = ", ".join(fortran_args)
        substitutions["call_args"] = ", ".join(call_args)

        if len(return_vars) == 0:
            substitutions["return"] = "Py_RETURN_NONE;"
        elif len(return_vars) == 1:
            substitutions["return"] = f"return {return_vars[0]};"
        else:
            return_str = f"PyObject* tuple = PyTuple_New({len(return_vars)});"
            for i, var in enumerate(return_vars):
                return_str += f"\n    Py_INCREF({var});"
                return_str += f"\n    PyTuple_SetItem(tuple, {i}, {var});"
            return_str += "\n    return tuple;"
            substitutions["return"] = return_str

        return Template(template).substitute(substitutions)

    def get_fortran_args(self, variable):
        """
        Returns the Fortran argument declaration for a given variable.
        Example for this function:

            void matmul(int32_t* a, int32_t* b, int32_t* c);

        this function returns the string 'int32_t* a' for the first argument.
        """

        if variable.to_pass_by_value:
            return f"{variable.datatype.get_cnumpy()} {variable.name}"
        elif settings.add_shape_descriptors and variable.shape.has_comptime_undefined_dims():
            return (
                f"npy_intp* {variable.name}_dims, {variable.datatype.get_cnumpy()}* {variable.name}"
            )
        else:
            return f"{variable.datatype.get_cnumpy()}* {variable.name}"

    def get_call_args(self, variable):
        """
        Returns the call argument declaration for a given variable.
        Example for this function:

            ciao((int32_t)a);

        this function returns the string '(int32_t)a' for the first argument.
        """
        if variable.to_pass_by_value:
            return f"({variable.datatype.get_cnumpy()}){variable.name}"
        elif variable.rank == 0 and variable.datatype.is_struct():
            return f"({variable.datatype.get_cnumpy()}*){variable.name}"
        elif settings.add_shape_descriptors and variable.shape.has_comptime_undefined_dims():
            return f"PyArray_DIMS({variable.name}), ({variable.datatype.get_cnumpy()}*)PyArray_DATA({variable.name})"
        else:
            return f"({variable.datatype.get_cnumpy()}*)PyArray_DATA({variable.name})"

    def get_initialization(self, i, variable):
        """
        Returns the declaration and initialization of the variable in the C API interface.
        For instance:

            int32_t a = (int32_t)PyLong_AsLongLong(args[0]);

        Where args[idx] is the corresponding argument in the Python function.
        """

        if variable.to_pass_by_value:
            if variable.datatype.get_numpy() in (np.complex64, np.complex128):
                result = "\n"
                result += "#if NPY_ABI_VERSION < 0x02000000\n"
                result += f"    {variable.datatype.get_cnumpy()} {variable.name};\n"
                result += f"    {variable.name}.real = PyComplex_RealAsDouble(args[{i}]);\n"
                result += f"    {variable.name}.imag = PyComplex_RealAsDouble(args[{i}]);\n"
                result += "#else\n"
                cast = variable.datatype.get_capi_cast(f"args[{i}]")
                result += f"    {variable.datatype.get_cnumpy()} {variable.name} = ({variable.datatype.get_cnumpy()}){cast};\n"
                result += "#endif"
                return result
            cast = variable.datatype.get_capi_cast(f"args[{i}]")
            return f"{variable.datatype.get_cnumpy()} {variable.name} = ({variable.datatype.get_cnumpy()}){cast};"
        elif variable.rank == 0 and variable.datatype.is_struct():
            result = f"{variable.datatype.get_cnumpy()}* {variable.name} = NULL;\n"
            result += f"     PyArray_ScalarAsCtype(args[{i}], &{variable.name});"
            return result
        return f"PyArrayObject *{variable.name} = (PyArrayObject*)args[{i}];"

    def get_check(self, variable):
        if variable.rank != 0:
            check_array = f"""
    if (!PyArray_Check({variable.name})) {{
        PyErr_SetString(PyExc_TypeError, "Argument '{variable.name}' must be a NumPy array");
        return NULL;
    }}"""
            if variable.shape.fortran_order:
                check_farray = f"""
    if (!PyArray_ISFARRAY({variable.name})) {{
        PyErr_SetString(PyExc_ValueError, "Input array '{variable.name}' is not Fortran contiguous or aligned.");
        return NULL; 
    }}"""
            else:
                check_farray = f"""
    if (!PyArray_ISCARRAY({variable.name})) {{
        PyErr_SetString(PyExc_ValueError, "Input array '{variable.name}' is not C contiguous or aligned.");
        return NULL; 
    }}"""
            if variable.datatype.is_struct():
                check_align = f"""
    if (!PyDataType_FLAGCHK((PyArray_Descr*)PyArray_DESCR({variable.name}), NPY_ALIGNED_STRUCT)) {{
        PyErr_SetString(PyExc_ValueError, "Input struct {variable.name} dtype is not aligned, use align=True ");
        return NULL;
    }}"""
                return check_array + check_farray + check_align
            else:
                check_type = f"""
    if (PyArray_TYPE({variable.name}) != {variable.datatype.get_cnumpy().upper()}) {{
        PyErr_SetString(PyExc_ValueError, "Input array '{variable.name}' does not have the required type ({variable.datatype.get_numpy()}) "); 
        return NULL;
    }}"""
                return check_array + check_farray + check_type
        else:
            return ""

            self.construct_module()

    def write(self, filename: Path):
        extension_module = self.construct_module()
        filename.parent.mkdir(exist_ok=True)
        filename.write_text(extension_module)
